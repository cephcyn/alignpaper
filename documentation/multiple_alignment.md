# multiple_alignment.ipynb

Contains code to import from the saved format generated by [analyze_ipynb](), align text, perform transformations on the alignment, score alignments, and search through the alignment space.

## Formats

### <a id="formatImport"></a>Import format

TODO elaborate?

### <a id="formatAlignment"></a>Alignment format

DataFrame with index=source text ID, columns titled txt0...txtN, and each cell is a tuple:

```
(text_of_cell, pos_of_entire_text, [list_of_pos_of_each_cell_word/token])
```

TODO elaborate

## Functions

### <a id="alignRowMajorLocal"></a>Text alignment (alignRowMajorLocal)

An implementation of Smith-Waterman for text alignment, using a [modified version of Smith-Waterman scoring function](#alignRowMajorLocal_scoringFunction)

TODO pseudocode

Inputs:
- align_a, align_b: [Alignment DataFrames](#formatAlignment) that we want to align together.
- use_types: Parameter for the scoring function, iff True then phrases must have identical phrase POS to match
- remove_empty_cols: iff True then strip out empty columns from the input alignment DFs (so forcibly remove gaps from the inputs)
- debug_print: ignore this, this only exists for debugging reasons

#### <a id="alignRowMajorLocal_scoringFunction"></a>alignRowMajorLocal scoring function (S-W scoring)

TODO elaborate

### <a id="splitCol"></a>Alignment column splitting (splitCol)

Split an [alignment column](#formatAlignment) using a word tree (either left-to-right or right-to-left)

Pseudocode:

```
Build word trie: - not in-depth as this is relatively standard trie building
  Initialize empty trie / prefix tree with an empty root node representing "phrase/list start"
  For each phrase (list of tokens) in the column:
    If performing right-to-left split, reverse the list of tokens
    Add list of tokens to trie, where each trie node is a single token
Collapse word trie:
  (Outermost execution: Set current trie node to root node)
  If current trie node has children:
    Collapse each of the child nodes
  If current trie node has exactly one child node:
    Combine the text of the current trie node and child node (if left-to-right, append; otherwise prepend)
    Assign each of the child node's children as the current trie node's children
  Return collapsed trie (the trie with current node as root is now fully collapsed)
Split into columns:
  N = height/depth of the collapsed word trie
  Create N new alignment table columns to replace the original column-to-be-split
  For each phrase in the old column:
    Get the list corresponding to tracing the phrase out in the collapsed word trie (if right-to-left, reverse the list)
    Write list element X into column X (if right-to-left, write element X into column N-X)
```

### <a id="mergeCol"></a>Alignment column merging (mergeCol)

Merge two [alignment columns](#formatAlignment) together.

Pseudocode:

```
For each row in the columns:
  Combine the raw text (append col2 to col1)
  Combine the phrase POS (uses the phrase POS of text in col1 if there is one, otherwise uses phrase POS of col2)
  Combine the list of token POSs (append col2 to col1)
Remove the extra column
```

### <a id="tempScoreVector"></a>Alignment scoring (tempScoreVector)

TODO - I need to rename this and update documentation when I clean up this function.

Calculates an overall score for a given [alignment table]((#formatAlignment). It does this by calculating a weighted sum of several sub-scores, each of which target different desired traits for a good text alignment.

TODO: explain score-per-column weighting and overall sub-score weighting

#### <a id="scoreNumColumns"></a>Score: number of columns (scoreNumColumns)

TODO

#### <a id="score_coltextcount"></a>Score: number of distinct phrases per column (score_coltextcount)

TODO

#### <a id="score_colptxtembed"></a>Score: phrase embedding variance per column (score_colptxtembed)

TODO

#### <a id="score_coltokncount"></a>Score: number of distinct tokens per column (score_coltokncount)

TODO

#### <a id="score_coltentcount"></a>Score: number of distinct entities per column (score_coltentcount)

TODO

#### <a id="score_colttuicount"></a>Score: number of distinct entity types per column (score_colttuicount)

TODO

#### <a id="score_colpposcount"></a>Score: number of distinct phrase POS per column (score_colpposcount)

TODO

#### <a id="score_coltposcount"></a>Score: number of distinct token POS per column (score_coltposcount)

TODO

#### <a id="score_colrepresent"></a>Score: number of rows that are represented per column (score_colrepresent)

TODO

#### <a id="scoreRowAlignment"></a>Score: [gap/mismatch score](#alignRowMajorLocal_scoringFunction) between a target row and the alignment (scoreRowAlignment)

TODO

#### <a id="score_termcolcount"></a>Score: weighted sum of how frequently target terms are repeated per column (score_termcolcount)

TODO

#### <a id="scoreRowLayoutCount"></a>Score: number of distinct row layouts (sequence of phrase-filled/gap) present in an alignment (scoreRowLayoutCount)

TODO
